Index: linux-4.14.65/drivers/irqchip/Makefile
===================================================================
--- linux-4.14.65.orig/drivers/irqchip/Makefile
+++ linux-4.14.65/drivers/irqchip/Makefile
@@ -5,6 +5,7 @@ obj-$(CONFIG_ALPINE_MSI)		+= irq-alpine-
 obj-$(CONFIG_ATH79)			+= irq-ath79-cpu.o
 obj-$(CONFIG_ATH79)			+= irq-ath79-intc.o
 obj-$(CONFIG_ATH79)			+= irq-ath79-misc.o
+obj-$(CONFIG_ATH79)                     += irq-ath79-pci.o
 obj-$(CONFIG_ARCH_BCM2835)		+= irq-bcm2835.o
 obj-$(CONFIG_ARCH_BCM2835)		+= irq-bcm2836.o
 obj-$(CONFIG_ARCH_EXYNOS)		+= exynos-combiner.o
Index: linux-4.14.65/drivers/irqchip/irq-ath79-pci.c
===================================================================
--- /dev/null
+++ linux-4.14.65/drivers/irqchip/irq-ath79-pci.c
@@ -0,0 +1,188 @@
+/*
+ *  Atheros AR71xx PCI interrupt controller
+ *
+ *  Copyright (C) 2015 Alban Bedel <albeu@free.fr>
+ *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
+ *  Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
+ *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
+ *
+ *  Parts of this file are based on Atheros' 2.6.15/2.6.31 BSP
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#define AR71XX_RESET_REG_PCI_INT_STATUS	0
+#define AR71XX_RESET_REG_PCI_INT_ENABLE	4
+
+#define AR71XX_PCI_INT_CORE			BIT(4)
+#define AR71XX_PCI_INT_DEV2			BIT(2)
+#define AR71XX_PCI_INT_DEV1			BIT(1)
+#define AR71XX_PCI_INT_DEV0			BIT(0)
+
+#define ATH79_PCI_IRQ_COUNT			5
+
+static void ath79_pci_irq_handler(struct irq_desc *desc)
+{
+	struct irq_domain *domain = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	void __iomem *base = domain->host_data;
+	u32 pending;
+
+	chained_irq_enter(chip, desc);
+
+	pending = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_STATUS) &
+		  __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	if (pending & AR71XX_PCI_INT_DEV0)
+		generic_handle_irq(irq_linear_revmap(domain, 1));
+
+	else if (pending & AR71XX_PCI_INT_DEV1)
+		generic_handle_irq(irq_linear_revmap(domain, 2));
+
+	else if (pending & AR71XX_PCI_INT_DEV2)
+		generic_handle_irq(irq_linear_revmap(domain, 3));
+
+	else if (pending & AR71XX_PCI_INT_CORE)
+		generic_handle_irq(irq_linear_revmap(domain, 4));
+
+	else
+		spurious_interrupt();
+
+	chained_irq_exit(chip, desc);
+}
+
+static void ar71xx_pci_irq_unmask(struct irq_data *d)
+{
+	void __iomem *base = irq_data_get_irq_chip_data(d);
+	u32 t;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	switch (d->hwirq) {
+	case 1:
+		t |= AR71XX_PCI_INT_DEV0;
+		break;
+	case 2:
+		t |= AR71XX_PCI_INT_DEV1;
+		break;
+	case 3:
+		t |= AR71XX_PCI_INT_DEV2;
+		break;
+	case 4:
+		t |= AR71XX_PCI_INT_CORE;
+		break;
+	default:
+		WARN(1, "Incorrect IRQ used for PCI device.");
+		return;
+	}
+
+	__raw_writel(t, base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	/* flush write */
+	__raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+}
+
+static void ar71xx_pci_irq_mask(struct irq_data *d)
+{
+	void __iomem *base = irq_data_get_irq_chip_data(d);
+	u32 t;
+
+	t = __raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	switch (d->hwirq) {
+	case 1:
+		t &= (~AR71XX_PCI_INT_DEV0);
+		break;
+	case 2:
+		t &= (~AR71XX_PCI_INT_DEV1);
+		break;
+	case 3:
+		t &= (~AR71XX_PCI_INT_DEV2);
+		break;
+	case 4:
+		t &= (~AR71XX_PCI_INT_CORE);
+		break;
+	default:
+		WARN(1, "Incorrect IRQ used for PCI device.");
+		return;
+	}
+
+	__raw_writel(t, base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+
+	/* flush write */
+	__raw_readl(base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+}
+
+static struct irq_chip ar71xx_pci_irq_chip = {
+	.name		= "AR71XX PCI",
+	.irq_unmask	= ar71xx_pci_irq_unmask,
+	.irq_mask	= ar71xx_pci_irq_mask,
+	.irq_mask_ack	= ar71xx_pci_irq_mask,
+};
+
+static int ar71xx_pci_irq_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)
+{
+	struct ar71xx_pci_controller *apc = d->host_data;
+
+	irq_set_chip_and_handler(irq, &ar71xx_pci_irq_chip, handle_level_irq);
+	irq_set_chip_data(irq, apc);
+
+	return 0;
+}
+
+static const struct irq_domain_ops pci_irq_domain_ops = {
+	.xlate = irq_domain_xlate_onecell,
+	.map = ar71xx_pci_irq_map,
+};
+
+static void __init ath79_pci_intc_domain_init(
+	struct irq_domain *domain, int irq)
+{
+	void __iomem *base = domain->host_data;
+
+	/* Disable and clear all interrupts */
+	__raw_writel(0, base + AR71XX_RESET_REG_PCI_INT_ENABLE);
+	__raw_writel(0, base + AR71XX_RESET_REG_PCI_INT_STATUS);
+
+	irq_set_chained_handler_and_data(irq, ath79_pci_irq_handler, domain);
+}
+
+static int __init ar7100_pci_intc_of_init(
+	struct device_node *node, struct device_node *parent)
+{
+	struct irq_domain *domain;
+	void __iomem *base;
+	int irq;
+
+	irq = irq_of_parse_and_map(node, 0);
+	if (!irq) {
+		pr_err("Failed to get PCI IRQ\n");
+		return -EINVAL;
+	}
+
+	base = of_iomap(node, 0);
+	if (!base) {
+		pr_err("Failed to get PCI IRQ registers\n");
+		return -ENOMEM;
+	}
+
+	domain = irq_domain_add_linear(node, ATH79_PCI_IRQ_COUNT,
+				&pci_irq_domain_ops, base);
+	if (!domain) {
+		pr_err("Failed to add PCI irqdomain\n");
+		return -EINVAL;
+	}
+
+	ath79_pci_intc_domain_init(domain, irq);
+	return 0;
+}
+
+IRQCHIP_DECLARE(ar7100_pci_intc, "qca,ar7100-pci-intc",
+		ar7100_pci_intc_of_init);
